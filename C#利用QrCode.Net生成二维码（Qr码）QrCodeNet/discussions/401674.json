[
  {
    "Id": "935690",
    "ThreadId": "401674",
    "Html": "\r\n<p>First of all, THANK YOU for this great work.</p>\r\n<p>I have a project that requires rendering of NUL and other non-printing characters in the QR code.</p>\r\n<p>The decoder to read this has the ability in capturing what is after NUL etc. So, to ordinary decoder, &quot;Part A \\0 Part B&quot; decodes to &quot;Part A&quot; but for this decoder, it reads both.</p>\r\n<p>Can it be implemented in QrCode.Net?</p>\r\n<p>If I input &quot;\\0&quot; in the string to encode, it simply renders image that decodes to &quot;\\0&quot;. It seems string in .NET simply ignore this. Also tried &quot;\\0000&quot; and it returns &quot;\\0&quot; when decoded.</p>\r\n<p>I was wondering if the &quot;Encode&quot; can also accept byte array as input.</p>\r\n<p>Again, thank you.</p>\r\n",
    "PostedDate": "2012-11-02T06:36:06.543-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "936231",
    "ThreadId": "401674",
    "Html": "<p>Do you have full control of decoder? I think first question is rather pointless if we can solve byte array right?</p>\r\n<p>&nbsp;</p>\r\n<p>For full control I mean you can access process within decode. There are few steps before you will get final result.&nbsp;</p>\r\n<p>Scan =&gt; Grab bit matrix =&gt; remove mask =&gt; get body bits array =&gt; detect which mode it use and which char encode table it uses. =&gt; decode bits array to char.&nbsp;</p>\r\n<p>If you have full control, last process you can terminate. Stop decoder at detect mode and char table step and grab your byte array. If you can not do that, it will be rather hard. QrCode it self (ISO specification) doesn't support byte array. They are base on char table. If you don't have full control of decoder, then it will be easier if you can find char table that doesn't have those null char.&nbsp;</p>\r\n<p>Full 8-bit-byte char table I have list under here.&nbsp;http://qrcodenet.codeplex.com/SourceControl/changeset/view/19827#236629</p>\r\n<p>Gma.QrCodeNet.Encoder.Dataencodation.ECIset.cs</p>\r\n<p>&nbsp;</p>\r\n<p>If you have full control, then we can expand ECI set. For example ECI value equal to 30 is for byte array. Then encode from there. If your decode find out its eight bit byte encode and ECI value is 30, then do not decode. Just extract full bit array to byte array.&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>If you don't have full control, then you have to find proper char table that doesn't have special char, use those char and put into encoder. Once fully decode, read string and translate back to byte array.&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>First option gives best performance but will need a lot of control on both encoder and decoder. Second option is easier.&nbsp;</p>",
    "PostedDate": "2012-11-03T22:38:45.327-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "936614",
    "ThreadId": "401674",
    "Html": "\r\n<p>Thank you for the through response, as always.</p>\r\n<p>Strange enough though, the client accepted the output images I generated by:</p>\r\n<p>1. Part A string encoded to byte array &#43; &quot;\\0&quot; or &quot;\\n&quot; encoded to byte array &#43;&nbsp;Part B string encoded to byte array. Just System.Buffer.BlockCopy, nothing fancy.</p>\r\n<p>2. Convert back the resulting array above to a string</p>\r\n<p>3. Encode the above string to QR code.</p>\r\n<p>In short, what I learnt are:</p>\r\n<p>1. The QR code generation, by and large, is not meant for byte array as input parameter.</p>\r\n<p>2. No one should expect control of decoder.</p>\r\n<p>Learnt a lot, thanks.</p>\r\n<p>Cliff</p>\r\n",
    "PostedDate": "2012-11-05T02:20:42.33-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]